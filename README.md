# esp-remote

**Seamless remote ESP8266/ESP32 development over SSH.**

Develop for ESP microcontrollers connected to remote Linux hosts (Raspberry Pi, Orange Pi, etc.) as if they were plugged into your local machine. No more walking to the device to flash firmware.

## The Problem

You have an ESP8266 or ESP32 connected to a Raspberry Pi in another room (or building). You want to:
- Flash firmware from your development machine
- Monitor serial output
- Have auto-reset work properly (DTR/RTS signals)
- Not remember which `/dev/ttyUSB*` is which device

## The Solution

```
Your Laptop                      Raspberry Pi
┌─────────────┐                 ┌─────────────┐
│ PlatformIO  │                 │   ser2net   │
│   esptool   │◄──SSH Tunnel───►│  (RFC2217)  │
│             │   port 4000     │      │      │
└─────────────┘                 │      ▼      │
                                │  /dev/esp-* │
                                │   (ESP32)   │
                                └─────────────┘
```

**esp-remote** sets up RFC2217 serial forwarding over SSH with:
- **Device registry** - Name your devices, track by chip-id
- **Persistent naming** - udev rules so devices keep their names after reboot
- **Multi-device support** - Multiple ESPs on one host, each on its own port
- **Git-tracked config** - Sync your device registry across machines
- **Tab completion** - Because life is too short to type full commands

## Quick Start

```bash
# Clone and install
git clone https://github.com/super-turbo-engineer/esp-remote.git
cd esp-remote
./install.sh
source ~/.bashrc  # or open new terminal

# Initialize your device registry
esp-remote init-registry

# Scan a remote host for ESP devices
esp-remote scan pi@raspberrypi
#                     ESP Devices Found
# ┏━━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━┓
# ┃ Device       ┃ Chip Type ┃ Chip ID    ┃ USB Path ┃
# ┡━━━━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━┩
# │ /dev/ttyUSB0 │ ESP32-D0  │ 0x12345678 │ 1-1.2    │
# │ /dev/ttyUSB1 │ ESP8266EX │ 0xabcdef01 │ 1-1.3    │
# └──────────────┴───────────┴────────────┴──────────┘

# Register devices with friendly names
esp-remote register living-room --chip-id 0x12345678 --host pi@raspberrypi --usb-path 1-1.2
esp-remote register garage-sensor --chip-id 0xabcdef01 --host pi@raspberrypi --usb-path 1-1.3

# Deploy ser2net config and udev rules to the Pi
esp-remote setup pi@raspberrypi
esp-remote udev-install pi@raspberrypi

# Connect to a device
esp-remote connect living-room
# living-room: Connected on port 4000
#   Upload: rfc2217://localhost:4000

# Flash with PlatformIO
pio run -t upload --upload-port rfc2217://localhost:4000

# Or monitor serial output
esp-remote monitor living-room
```

## Commands

| Command | Description |
|---------|-------------|
| `init-registry [url]` | Initialize registry (optionally clone from git URL) |
| `scan <host>` | Scan remote host for ESP devices with chip-ids |
| `register <name>` | Register a device with a friendly name |
| `unregister <name>` | Remove a device from registry |
| `setup <host>` | Install/update ser2net config on remote host |
| `udev-install <host>` | Install udev rules for persistent `/dev/{name}` symlinks |
| `connect [device]` | Create SSH tunnel(s) to device(s) |
| `disconnect [device]` | Close SSH tunnel(s) |
| `status` | Show all devices and connection status |
| `monitor <device>` | Open serial monitor |
| `verify <device>` | Verify chip-id matches before flashing |
| `sync` | Commit and push registry changes to git |

## How It Works

### On the Remote Host (Raspberry Pi)

**ser2net** exposes serial ports via the RFC2217 protocol, which supports control signals (DTR/RTS) needed for auto-reset:

```yaml
# /etc/ser2net.yaml (auto-generated by esp-remote setup)
connection: &living_room
  accepter: telnet(rfc2217),tcp,4000
  connector: serialdev,/dev/living-room,115200n81,local
  options:
    kickolduser: true
```

**udev rules** create persistent symlinks based on USB port:

```bash
# /etc/udev/rules.d/99-esp-devices.rules (auto-generated)
SUBSYSTEM=="tty", KERNELS=="1-1.2", SYMLINK+="living-room", MODE="0666"
```

### On Your Local Machine

**SSH tunnels** forward the ser2net ports securely:

```bash
ssh -L 4000:127.0.0.1:4000 pi@raspberrypi
```

**PlatformIO/esptool** connects via RFC2217 URL:

```ini
# platformio.ini
upload_port = rfc2217://localhost:4000
monitor_port = rfc2217://localhost:4000
```

## Device Registry

Devices are stored in `~/.esp-remote/registry/devices.toml`:

```toml
[device.living-room]
chip_id = "0x12345678"
host = "pi@raspberrypi"
usb_path = "1-1.2"
remote_port = 4000
local_port = 4000
description = "ESP32 temperature sensor"

[device.garage-sensor]
chip_id = "0xabcdef01"
host = "pi@raspberrypi"
usb_path = "1-1.3"
remote_port = 4001
local_port = 4001
description = "ESP8266 door sensor"
```

The registry is a git repo. Use `esp-remote sync` to version control your device configuration and share across machines.

## Requirements

**Local machine:**
- Python 3.9+
- [uv](https://github.com/astral-sh/uv) package manager
- SSH access to remote host

**Remote host (Raspberry Pi, etc.):**
- Linux with systemd
- USB-serial devices (`/dev/ttyUSB*` or `/dev/ttyACM*`)
- SSH server
- Will auto-install: ser2net, esptool (via pip)

## Why RFC2217?

Unlike simple TCP-to-serial bridges (like `socat` or raw `ser2net`), RFC2217 is a Telnet extension that passes **control signals** over the network. This means:

- **Auto-reset works** - DTR/RTS pulses trigger the ESP bootloader
- **No manual button pressing** - Just run `pio run -t upload`
- **Same experience as local** - esptool and PlatformIO support it natively

## Tips

### PlatformIO Configuration

```ini
[env:myesp32]
platform = espressif32
board = esp32dev
framework = arduino

upload_port = rfc2217://localhost:4000
monitor_port = rfc2217://localhost:4000
monitor_speed = 115200
```

### Multiple Hosts

Register devices from different hosts - each gets its own local port:

```bash
esp-remote register kitchen --chip-id 0x111 --host pi@kitchen-pi
esp-remote register garage --chip-id 0x222 --host pi@garage-pi
esp-remote connect  # connects to all
```

### Sync Registry Across Machines

```bash
# First machine - push to git
esp-remote init-registry
# ... register devices ...
cd ~/.esp-remote/registry
git remote add origin git@github.com:you/esp-devices.git
git push -u origin main

# Second machine - clone existing
esp-remote init-registry git@github.com:you/esp-devices.git
```

## Uninstall

```bash
./install.sh uninstall
```

This removes shell configuration but preserves your device registry.

## License

MIT
